# Introduction

Welcome to the official documentation of the Matter and Form THREE scanner's public API. This documentation provides detailed information about the API calls available for controlling and interacting with the THREE scanner.

The THREE comes equipped with a backend server that activates on boot. This server communicates via a WebSocket protocol, allowing for full control over the scanner's functionalities—everything the THREE does, except for the GUI, is accessible through this server. All the calls our frontend system makes are also available for your personal projects.

Using the WebSocket server, you can build your own integrations with automation systems. Whether you want to take stereo images with the dual cameras, project graphics through the built-in projector, or even design a completely new front-end 3D scanning system, our API provides the flexibility for all these activities and more.

## Overview 

- [Getting Started](#getting-started)
    - [Connecting to the THREE](#connecting-to-the-three)
    - [Interacting with the THREE](#interacting-with-the-three)
      - [Task Messages](#task-messages)
      - [Buffer Messages](#buffer-messages)
- [Basic Usage Examples](#basic-usage)
  - [Connect to the server](#connect-to-the-server) 
  - [Creating a new project](#creating-a-new-project) 
  - [Opening a project](#opening-a-project) 
  - [Creating a scan](#creating-a-scan) 
- [Protocol Documentation](#protocol-documentation)

# Getting Started

## Connecting to the THREE

If you are new to WebSockets and would like to learn more, you can read about them [here](https://en.wikipedia.org/wiki/WebSocket#:~:text=WebSocket%20is%20a%20computer%20communications,as%20RFC%206455%20in%202011.). Alternatively, you can search for WebSocket libraries that are compatible with the programming language of your choice. 

Connect to the WebSocket server over port 8081: `ws://matterandform.local:8081`, or use the local IP address of the device: `ws://192.168.XXX.XXX:8081`. The projector displays the local IP address of the THREE scanner on boot.

Please note that the THREE scanner is a local network device and can only be communicated with from within the same network by default.

> Refer to the [Basic Usage](#basic-usage) section for a more complete code snippet in Python and JavaScript to help you get up and running.

```javascript
const WebSocket = require('ws');

const ws = new WebSocket('ws://matterandform.local:8081');
```

```python
import asyncio
import websockets

async def connect():
    await websockets.connect("ws://matterandform.local:8081")

asyncio.run(connect())
```

## Interacting with the THREE

The server and the client exchange messages mainly in JSON format. The two exceptions are 3D scan data, and image data. The server will normally only respond to requests that are sent by an application.

Every action, whether it’s starting a new scan, adjusting settings, or querying the device status, is encapsulated as a **task**. When a task is submitted to the server, it is queued and processed in sequence. 

Refer to the [Basic Usage](#basic-usage) section for code snippets in both Python and JavaScript to help you get up and running.

<a name="MF-V3-Task"></a>

## Task Messages
Generic task message for the Three Scanner.

A task message is a generic message encoded as JSON which is used for enqueuing a task to be performed by the THREE Scanner. The THREE scanner dispatches updates and results for tasks to the client using the same message type.

| Field | Type | Label | Description |
| ----- | ---- | ----- | ----------- |
| Index | [int32](#int32) |  | A unique identifier generated by the client. This identifier associates all incoming and outgoing task messages with a specific task requested by the client. |
| Type | [string](#string) |  | The string identifying the task type. See task definitions for the list of valid task strings. |
| Input | [Any](#Any) | optional | Optional input message. See each task definition for details. |
| Output | [Any](#Any) | optional | Optional output message. See each task definition for details. |
| State | [TaskState](#MF-V3-TaskState) | optional | The current state of the task. |
| Error | [string](#string) | optional | A string describing the error if the task has failed. |

The following is an example of a raw JSON request from the client and response from the server which modifies the current camera settings using the [SetCameras](#MF_V3_Tasks_SetCameras) task.

> Example request:

```json
{
    "Task": {
        "Index": 1,
        "Type": "SetCameras"
        "Input": {
            "analogGain": 256,
            "digitalGain": 128,
            "exposure": 18000
        }
    }
}
```

> Example response:

```json
{
    "Task": {
        "Index": 1,
        "Type": "SetCameras"
        "Input": {
            "analogGain": 256,
            "digitalGain": 512,
            "exposure": 18000
        },
        "Output": {
            "analogGain": {
                "default": 512.0,
                "max": 1024.0, 
                "min": 256.0, 
                "value": 256.0
            },
            "digitalGain": {
                "default": 256,
                "max": 65536,
                "min": 256,
                "value": 512
            },
            "exposure": {
                "default": 27000,
                "max": 90000,
                "min": 9000,
                "value": 18000
            }
        },
        "State": "Completed"
    }
}
```

<a name="MF-V3-TaskState"></a>

### Task State

| Name | Description |
| ---- | ----------- |
| None | The task state is not defined. |
| Sent | The task has been sent by the client. |
| Received | The task has been received by the server. |
| Started | The task started by the server. |
| Completed | The task is completed by the server. |
| Cancelled | The task has been cancelled by the client. |
| Failed | The task has failed. A string describing the error is returned with the task. |
| Dropped | The task has not been received by the server, or task IDs were sent out of sequence. |
| Disconnected | The client has been disconnected from the server before the task could finish. |

<a name="MF-V3-Buffer"></a>

## Buffer Messages

Generic buffer message for the Three Scanner.

Some tasks require the server and/or client to transfer binary data.  In such cases the _buffer message_ is sent to inform the server/client what the data is and what task it belongs to.  The binary data it refers to is sent immediately following the buffer message.

| Field | Type | Label | Description |
| ----- | ---- | ----- | ----------- |
| Index | [int32](#int32) |  | The zero-based index identifying the data buffer. |
| Size | [uint64](#uint64) |  | The size of the incoming data buffer in bytes. |
| Task | [Task](#MF-V3-Task) |  | The task associated with the data buffer. This informs the client which request this data buffer corresponds to. |
| Descriptor | [Any](#Any) | optional | Optional data buffer descriptor. See each task definition for details. |


> Example request: the `DownloadProject` task requests for the server to transfer a ZIP file containing the project data to the client.

```json
{
    "Task": {
        "Index": 1,
        "Type": "DownloadProject",
        "Input": 5
    }
}
```

> The server responds with a buffer message informing the client to expect a binary data transfer. Notice that the buffer message `Task` field echoes the initial task request so that it is clear which request this data is a response to. A `Size` field is also included so that the client knows how many bytes it should expect to receive.

```json
{
    "Buffer": {
        "Descriptor": "Project-5.zip",
        "Index": 0,
        "Size": 15682096,
        "Task": {
            "Index": 1,
            "Type": "DownloadProject",
            "Input": 5
        }
    }
}
```

> The server then sends the 15682096 byte data buffer of the project ZIP file (in 32MB chunks at most). Once the server is finished streaming the binary buffer it sends a task completion message.

```json
{
    "Task": {
        "Index": 1,
        "Type": "DownloadProject"
        "Input": 5,
        "State": "Completed"
    }
}
```

# Basic Usage

This section contains step-by-step instructions for connecting to, and interacting with, the THREE WebSocket API. In particular, the example here demonstrates how to establish a connection, send tasks, and handle responses from the server, using Python and JavaScript. 

### Setup: Using Python

To run the Python code snippet, Python 3.8 or newer is required. You will also need to install the [websockets](https://websockets.readthedocs.io) library.

- Ensure Python 3.8 or newer is installed. You can download it from [python.org](https://www.python.org/downloads/).
- To install websockets, run `pip install websockets` in your command line.
- Copy and paste the code snippets into a file named `example.py`.
- Run the script with `python /path/to/example.py` or `python3 /path/to/example.py`, depending on your system configuration.

### Setup: Using JavaScript

To run the JavaScript code snippet, Node.js 10.0.0 or newer is required. You will also need to install the [ws](https://www.npmjs.com/package/ws) library.

- Ensure Node.js 10.0.0 or newer is installed. You can download it from [nodejs.org](https://nodejs.org).
- To install ws, run `npm install ws` in your project directory.
- Copy and paste the code snippets into a file named `example.js`.
- Run the script with `node /path/to/example.js` or `nodejs /path/to/example.js`, depending on your system configuration.

## Interacting with a Project

### Connect to the server

In order to interact with the WebSocket API, we first need to connect to it. We can use the following Python or JavaScript code snippet to do that.

> Using Python:

```python
import asyncio
import json
import websockets

class THREE:
    def __init__(self, url):
        self.url = url

    async def connect(self):
        self.ws = await websockets.connect(self.url)

    async def send(self, task):
        await self.ws.send(json.dumps(task))

        async for message in self.ws:
            try:
                response = json.loads(message)
                if 'Task' in response and 'State' in response['Task'] and response['Task']['Index'] == task['Task']['Index']:
                    if response['Task']['State'] == 'Failed':
                        raise Exception(response['Task'])
                    elif response['Task']['State'] == 'Completed':
                        return response['Task'].get('Output', {})
            except Exception as e:
                raise e

async def main():
    three = THREE('ws://matterandform.local:8081')
    try:
        # Open a connection with the server
        await three.connect()
        print(f"Connected to the server @ {three.url}")

        # Your application logic here

    except Exception as e:
        print(f"Error: {e}")
    finally:
        await three.ws.close()

asyncio.run(main())
```

> Using JavaScript:

```javascript
const WebSocket = require('ws');

function THREE(url) { this.url = url; }

THREE.prototype.connect = function() {
    this.ws = new WebSocket(this.url);
    return new Promise((resolve, reject) => {
        this.ws.onopen = resolve;
        this.ws.onclose = reject;
    });
};

THREE.prototype.send = function(task) {
    return new Promise((resolve, reject) => {
        this.ws.onmessage = event => {
            try {
                const response = JSON.parse(event.data);
                if (!response.Task || response.Task.Index !== task.Task.Index) return;
                if (response.Task.State === 'Failed') reject(response.Task);
                if (response.Task.State === 'Completed') resolve(response.Task.Output ?? {});
            } catch (error) { reject(error); }
        };
        this.ws.onerror = error => reject(error);
        this.ws.send(JSON.stringify(task));
    });
};

const main = async () => {
    const three = new THREE('ws://matterandform.local:8081');

    try {
        // Open a connection with the server
        await three.connect();
        console.log(`Connected to the server @ ${three.url}`);

        // Your application logic here
    }
    catch (error) { console.error('Error:', error); }
    finally { three.ws?.close(); }
}

main();
```

> [!CAUTION]  
> Note: these code snippets are intended to help you get up and running, and for quick prototyping only. In a production environment you will want to enhance this code (or simply re-write it) to be more robust and fault tolerant.


### Creating a New Project

Scans are stored in project, and so before we may create a new scan we must first open a project. We can create a new project by sending a `NewProject` task with the `Input` field set to the name we want to give the project.

Once successful, the `NewProject` task will return a message with the `State` field set to `Completed`, and an `Output` field containing metadata about the newly created project including an `index` field which is used to identify it. We use the `index` field in the next step.

> Using Python:

```python
create_project_response = await three.send({
    "Task": {
        "Index": 1,
        "Type": "NewProject",
        "Input": "My Project Name"
    }
})
print('Project created:', create_project_response)
```

> Using JavaScript:

```javascript
const createProjectResponse = await three.send({
    Task: {
        Index: 1,
        Type: "NewProject",
        Input: "My Project Name"
    }
});
console.log('Project created:', createProjectResponse);
```

> Example response:
```json
{
  "groups": { "collapsed": false, "index": 0, "name": "", "visible": true },
  "index": 19,
  "name": "My Project Name"
}
```

### Opening a Project

After creating a new project, we can open it. Opening a project allows the current socket connection to interact with it, such as adding and editing scan data. To open a project we send a `OpenProject` task with the `Input` field set to be the `index` obtained in the previous step.

> Using Python:

```python
# Open the project created in the previous step
open_project_response = await three.send({
    "Task": {
        "Index": 2,
        "Type": "OpenProject",
        "Input": create_project_response['index']
    }
})
print('Project opened:', open_project_response)
```

> Using JavaScript:

```javascript
// Open the project created in the previous step
const openProjectResponse = await three.send({
    Task: {
        Index: 2,
        Type: "OpenProject",
        Input: createProjectResponse.index
    }
});
console.log('Project opened:', openProjectResponse);
```

> Example response:
```json
{
  "groups": { "collapsed": false, "index": 0, "name": "", "visible": true },
  "index": 19,
  "name": "My Project Name"
}
```

> [!NOTE]
> Note that the project will remain open for the lifetime of the socket connection or until you explicitly close it by sending a `CloseProject` task. Projects can only be open by a single socket connection at a given time.

### Creating a Scan

Once we've opened a project we are ready to interact with it. For example, we can create a new scan by sending a `NewScan` task with the `Input` field set to be some scan configuration.

> Using Python:

```python
# Add a new scan to the opened project
new_scan_response = await three.send({
    "Task": {
        "Index": 3,
        "Type": "NewScan",
        "Input": {
            "camera": { "exposure": 18000, "analogGain": 256, "digitalGain": 256 },
            "capture": { "quality": "Medium", "texture": True },
            "projector": { "brightness": 0.8 }
        }
    }
})
print('New scan added:', new_scan_response)
```

> Using JavaScript:

```javascript
// Add a new scan to the opened project
const newScanResponse = await three.send({
    Task: {
        Index: 3,
        Type: "NewScan",
        Input: {
            camera: { exposure: 18000, analogGain: 256, digitalGain: 256 },
            capture: { quality: "Medium", texture: true },
            projector: { brightness: 0.8 }
        }
    }
});
console.log('New scan added:', newScanResponse);
```

> Example response:

```json
{
  "index": 0,
  "name": "",
  "collapsed": false,
  "groups": [
    {
      "index": 1,
      "name":"Scan-1",
      "collapsed": false,
      "color": [0.6150012612342834,0.8566378951072693,0.916047215461731,1],
      "rotation": [-0.003504337305992789,0.16057781988162367,-0.006117077953868702],
      "scan": 1,
      "translation": [-127.42007942138065,18.583630764869238,-293.1252968900822],
      "visible": true
    }
  ],
  "visible": true
}
```

